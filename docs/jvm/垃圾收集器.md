# 垃圾收集器与内存分配策略

[[toc]]

## 垃圾收集方法

### 引用计数法

为每一个对象添加一个计数器，当有对象引用时+1，失去引用时-1，计数器为0时标记为可回收

### 可达性分析算法

GC Roots无法引用的就是不可达对象，不可达对象可被回收

GC Roots对象

- 栈帧的本地变量表中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

强弱软虚引用？

#### 标记清除算法

1. 标记所有对象
2. 合适的时间进行回收

缺点：

1. 效率不高
2. 大量的空间碎片

图

#### 标记复制算法

将内存一分为二，一半用完之后将可达对象复制到另一半，然后将该区域进行清理

缺点：浪费一半内存

图

#### 标记整理算法

1. 标记所有对象
2. 合适的时间整理
3. 可用对象之外的区域进行回收

图

### 安全点

并非在程序执行的任意时刻都可以进行gc，只有在特定的位置才能进行gc，这些位置称为安全点。当线程中的程序运行到安全点时进行中断进行gc，gc完毕后继续执行

缺点：线程处于Sleep或Blocked状态时，无法响应JVM的中断请求，无法“走”到安全的地方中断挂起

### 安全区域

为了解决安全点的问题，就需要安全区域来解决。安全区域是指在一段代码片段中，引用关系不会发生变化。当线程进入安全区域后，在进行gc时就可以不必管这些在安全区域内的线程了。

离开安全区域的两个条件，满足其一即可

1. 系统已完成跟节点枚举（或这个GC）
2. 收到可以离开的信号

## 垃圾收集器

### 各垃圾收集器对比

| 垃圾器名          | GC线程数 | 采用收集算法 | 处理区域 | 可配合老（新）年代处理器     | 备注                                                         | 使用参数                |
| ----------------- | -------- | ------------ | -------- | ---------------------------- | ------------------------------------------------------------ | ----------------------- |
| Serial            | 单线程   | 复制         | 新生代   | CMS<br />Serial Old          | 最基本，发展最悠久的收集器                                   | -XX:+UseSerialGC        |
| ParNew            | 多线程   | 复制         | 新生代   | CMS<br />Serial Old          | Serial的多线程版本                                           | -XX:+UseParNewGC        |
| Parallel Scavenge | 多线程   | 复制         | 新生代   | Serial Old<br />Parallel Old | 关注吞吐量而非垃圾收集时间                                   | -XX:+UseParallelGC      |
| Serial Old        | 单线程   | 标记整理     | 老年代   | all                          | Servial的老年代版本                                          |                         |
| Parallel Old      | 多线程   | 标记整理     | 老年代   | Parallel Scavenge            | Parallel Scavenge的老年代版本                                | -XX:+UseParallelOldGC   |
| CMS               | 多线程   | 标记清除     | 老年代   | Serial<br />ParNew           | 步骤复杂：<br />1. 初始标记<br />2. 并发标记<br />3. 重新标记<br />4. 并发清除 | -XX:+UseConcMarkSweepGC |
| G1                | 多线程   |              | all      |                              |                                                              | -XX:+UseG1GC            |

### G1垃圾收集器详解

G1垃圾收集器的使命是替代CMS垃圾收集器，那么CMS垃圾收集器有哪些不足呢？

1. CMS垃圾收集器使用并发收集的方式，需要占用CPU资源，当CPU只有单核或双核时效率低下
2. 无法清除浮动垃圾，处理器在初始标记和并发标记之间产生的垃圾只能等到下次才能清除，且CMS收集器需要一定的内存来进行垃圾回收
3. 大量的垃圾碎片，标记清除方法的弊端

未完待续。。。